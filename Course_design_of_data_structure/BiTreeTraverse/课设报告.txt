三、二叉树的应用 (必做)（二叉树）
1.[问题描述]
编程实现二叉树的建立，先序、中序、后序（递归和非递归方法）、层序遍历。求二叉树的高度、宽度，结点数。判断是否为二叉排序树。
[基本要求]	
（1） 从文件中读入建树信息，树的节点数目不小于20个，树的高度不小于4。
（2） 采用二叉链表结构。
（3） 至少2组输入数据，分别是二叉排序树和不是二叉排序树，

2.采用的数据结构

typedef struct BiTNode
{
	TElemType data;
	struct BiTNode  *lchild,*rchild; 
}BiTNode,*BiTree;


3.算法思想

深度：
若当前结点为空则返回0，不为空则递归求孩子结点的深度 ，返回较大的那个加一为当前结点的深度。

结点数：
访问函数运行了几次则结点数为几。

宽度以及层次遍历：

利用双队列层次遍历的思想实现。首先将根节点入a队，求其队列的长度，循环出队并将孩子入b队，求其长度并留最大值。B队列循环出队并将孩子结点存入a队，循环次过程，直到ab队均空。

排序二叉树判断：
通过中序遍历实现，将中序遍历的visit函数稍加修改，每次访问时比较与前一个访问的结点的大小关系，若大继续访问，若小，则跳出，并得出该二叉树不是排序二叉树。


非递归遍历思想：
1,先序遍历
每访问一个节点都将其右子树入栈，不管右子树是否为空。然后进入左子树，然后继续访问与入栈。当左子树不存在的时候，pop（），即返回到同一父母结点的右子树上，继续上述循环，从而完成先序遍历。
2，中序遍历
大致思想与先序类似。即每到达一个非空结点则将其入栈进入其左子树，不断循环，当左子树为空时出栈，即回到父母结点，然后访问，进入其右子树，继续循环，从而完成中序遍历。
3，后续遍历
后续遍历相对前两个多了个last指针，用来标记上一个被访问的树。
（一）．首先，若当前结点非空，则循环入栈进入左子树，即将其左下方	在一条直线上的左子树全部入栈，当当前树为空时出栈。
出栈就是退回到其父母结点：
（二）．（1）若其右子树非空，则用last判断是否刚刚被访问过，若未			访问则进入该右子树，继续循环存储左下方在一条直线上的左子			树，回到上一步。
（2）若右子树为空，或者last==其右子树，则访问当前结点。访问		之后要退回上一结点，即出栈，回到（二）。所以要让p=NULL，		无需将该结点继续作为左子树入栈。然后继续进行右子树是否被		访问过的判断。
